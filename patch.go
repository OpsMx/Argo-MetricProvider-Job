package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/argoproj/argo-rollouts/utils/defaults"
	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// TODO - Try to retrieve the state of the analysis run and then patch on that
// TODO - Reuse the components/structs - create a small function to patch ARs
//TODO - Use a logger

// TODO - Structs should look like OG structs
/*
type AutoGenerated struct {
	Status Status `json:"status"`
}
type Metadata struct {
	JobName   string `json:"job-name"`
	CanaryID  string `json:"canaryId"`
	GateURL   string `json:"gateUrl"`
	ReportURL string `json:"reportUrl"`
	Score     string `json:"score"`
}
type Measurements struct {
	Phase    string   `json:"phase"`
	Message  string   `json:"message"`
	Metadata Metadata `json:"metadata"`
}
type MetricResults struct {
	Name         string         `json:"name"`
	Phase        string         `json:"phase"`
	Measurements []Measurements `json:"measurements"`
}
type Status struct {
	MetricResults []MetricResults `json:"metricResults"`
}

func patchCanaryDetails(p *Clients, ctx context.Context, analysisRunName string, cd CanaryDetails) {
	//TODO - Introduce more checks, remove prints and check what should be passed as pointers
	ns := defaults.Namespace()
	reportURLStruct := AutoGenerated{
		Status: Status{
			[]MetricResults{{
				Name:  cd.metricName,
				Phase: cd.phase,
				Measurements: []Measurements{{
					Phase: cd.phase,
					Metadata: Metadata{
						JobName:   cd.jobName,
						CanaryID:  cd.canaryId,
						GateURL:   cd.gateUrl,
						ReportURL: cd.reportUrl,
					},
				},
				}},
			},
		}}

	jsonData, err := json.Marshal(reportURLStruct)
	if err != nil {
		fmt.Printf("could not marshal json: %s\n", err)
	}
	fmt.Println("The json data for patch is ...")
	fmt.Printf("%v", string(jsonData))
	arPatch, err := p.argoclientset.ArgoprojV1alpha1().AnalysisRuns(ns).Patch(ctx, analysisRunName, types.MergePatchType, jsonData, metav1.PatchOptions{})
	if err != nil {
		fmt.Println("Problem in arPatch")
		fmt.Printf("%s", err)
	}
	fmt.Printf("%v", arPatch)

}

func patchFinalStatus(p *Clients, ctx context.Context, analysisRunName string, cd CanaryDetails) {
	//TODO -Merge with the patchCanaryDetails function
	ns := defaults.Namespace()

	finalStatus := AutoGenerated{
		Status: Status{
			[]MetricResults{{
				Name:  cd.metricName,
				Phase: cd.phase,
				Measurements: []Measurements{{
					Phase: cd.phase,
					Metadata: Metadata{
						JobName:   cd.jobName,
						CanaryID:  cd.canaryId,
						GateURL:   cd.gateUrl,
						ReportURL: cd.reportUrl,
						Score:     cd.value,
					},
				},
				}},
			},
		}}

	jsonData, err := json.Marshal(finalStatus)
	if err != nil {
		fmt.Printf("could not marshal json: %s\n", err)
	}
	fmt.Println("The json data for patch is ...")
	fmt.Printf("%v", string(jsonData))
	arPatch, err := p.argoclientset.ArgoprojV1alpha1().AnalysisRuns(ns).Patch(ctx, analysisRunName, types.MergePatchType, jsonData, metav1.PatchOptions{})
	if err != nil {
		fmt.Println("Problem in arPatch")
		fmt.Printf("%s", err)
	}
	fmt.Printf("%v", arPatch)
}

func patchError(p *Clients, ctx context.Context, analysisRunName string, fs FinalStatus) error {
	//Pass in an Error custom message to the AR and exit the pod with non 0 status code
	ns := defaults.Namespace()

	statusStruct := AutoGenerated{
		Status: Status{
			[]MetricResults{{
				Name:  fs.metricName,
				Phase: fs.phase,
				Measurements: []Measurements{{
					Phase:   fs.phase,
					Message: fs.message,
					Metadata: Metadata{
						JobName: fs.jobName,
					},
				},
				}},
			},
		}}

	jsonData, err := json.Marshal(statusStruct)
	if err != nil {
		return err
	}
	log.Infof("The json data for patch is %s",string(jsonData))

	arPatch, err := p.argoclientset.ArgoprojV1alpha1().AnalysisRuns(ns).Patch(ctx, analysisRunName, types.MergePatchType, jsonData, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	log.Infof("%v", arPatch)
	os.Exit(1)
	return nil
}

func patchFailedInconclusive(p *Clients, ctx context.Context, analysisRunName string, reason string, cd CanaryDetails) {
	//TODO -Merge with the patchCanaryDetails function
	// TODO -change the reason arg to be more confined
	ns := defaults.Namespace()

	finalStatus := AutoGenerated{
		Status: Status{
			[]MetricResults{{
				Name:  cd.metricName,
				Phase: cd.phase,
				Measurements: []Measurements{{
					Phase: cd.phase,
					Message: fmt.Sprintf("The final score doesn't meet the scoring criterion, the analysis was %s", reason),
					Metadata: Metadata{
						JobName:   cd.jobName,
						CanaryID:  cd.canaryId,
						GateURL:   cd.gateUrl,
						ReportURL: cd.reportUrl,
						Score:     cd.value,
					},
				},
				}},
			},
		}}

	jsonData, err := json.Marshal(finalStatus)
	if err != nil {
		fmt.Printf("could not marshal json: %s\n", err)
	}
	fmt.Println("The json data for patch is ...")
	fmt.Printf("%v", string(jsonData))
	arPatch, err := p.argoclientset.ArgoprojV1alpha1().AnalysisRuns(ns).Patch(ctx, analysisRunName, types.MergePatchType, jsonData, metav1.PatchOptions{})
	if err != nil {
		fmt.Println("Problem in arPatch")
		fmt.Printf("%s", err)
	}
	fmt.Printf("%v", arPatch)

	patchJobFailureInconclusive(p,ctx,cd.jobName, reason)
	os.Exit(1)
}

func patchJobFailureInconclusive(p *Clients, ctx context.Context, jobName, reason string) {

	//TODO -Move the structs out of the func
	type Conditions struct {
		Message string `json:"message,omitempty"`
		Type    string `json:"type,omitempty"`
		Status  string `json:"status,omitempty"`
	}

	type Status struct {
		Conditions []Conditions `json:"conditions,omitempty"`
	}

	type JobStatus struct {
		Status Status `json:"status,omitempty"`
	}
	//TODO- check the meaning of the status of the Job
	jobStatus := JobStatus{
		Status: Status{
			Conditions: []Conditions{{
				Message: fmt.Sprintf("The analysis was %s", reason),
				Type: "Running",
				Status: "True",
			},
		},
		},
	}
	jsonData, err := json.Marshal(jobStatus)
	if err != nil {
		fmt.Printf("could not marshal json: %s\n", err)
	}

	jobPatch,err := p.kubeclientset.BatchV1().Jobs(defaults.Namespace()).Patch(ctx,jobName, types.StrategicMergePatchType,jsonData,metav1.PatchOptions{},"status")
	if err != nil {
		fmt.Printf("%s",err)

	fmt.Printf("json data: %s\n", jobPatch)
	os.Exit(1)
}
}
*/
type Conditions struct {
	Message       string      `json:"message,omitempty"`
	Type          string      `json:"type,omitempty"`
	Status        string      `json:"status,omitempty"`
	LastProbeTime metav1.Time `json:"lastProbeTime,omitempty"`
}

type Status struct {
	Conditions *[]Conditions `json:"conditions,omitempty"`
}

type JobStatus struct {
	Status Status `json:"status,omitempty"`
}

func patchJobCanaryDetails(p *Clients, ctx context.Context, jobName string, cd CanaryDetails) {

	//TODO- check the meaning of the status of the Job
	jobStatus := JobStatus{
		Status: Status{
			Conditions: &[]Conditions{{
				Message:       fmt.Sprintf("Canary ID: %s\nReport URL: %s\nGate URL: %s", cd.canaryId, cd.reportUrl, cd.gateUrl),
				Type:          "OpsmxAnalysis",
				LastProbeTime: metav1.NewTime(time.Now()),
				Status:        "True",
			},
			},
		},
	}
	jsonData, err := json.Marshal(jobStatus)
	if err != nil {
		log.Errorf("could not marshal json: %s\n", err)
	}

	jobPatch, err := p.kubeclientset.BatchV1().Jobs(defaults.Namespace()).Patch(ctx, jobName, types.StrategicMergePatchType, jsonData, metav1.PatchOptions{}, "status")
	if err != nil {
		log.Errorf("%s", err)
	}
	log.Infof("json data: %s\n", jobPatch)
}

func patchJobSuccessful(p *Clients, ctx context.Context, jobName string, cd CanaryDetails) {

	//TODO- check the meaning of the status of the Job
	jobStatus := JobStatus{
		Status: Status{
			Conditions: &[]Conditions{{
				Message:       fmt.Sprintf("Canary ID: %s\nReport URL: %s\nGate URL: %s Score: %s", cd.canaryId, cd.reportUrl, cd.gateUrl, cd.value),
				Type:          "OpsmxAnalysis",
				LastProbeTime: metav1.NewTime(time.Now()),
				Status:        "True",
			},
			},
		},
	}
	jsonData, err := json.Marshal(jobStatus)
	if err != nil {
		log.Errorf("could not marshal json: %s\n", err)
	}

	jobPatch, err := p.kubeclientset.BatchV1().Jobs(defaults.Namespace()).Patch(ctx, jobName, types.StrategicMergePatchType, jsonData, metav1.PatchOptions{}, "status")
	if err != nil {
		log.Errorf("%s", err)
	}
	log.Infof("json data: %s\n", jobPatch)
}

func patchJobFailedOthers(p *Clients, ctx context.Context, jobName, reason string, cd CanaryDetails, errCode int) {
	//TODO- check the meaning of the status of the Job
	jobStatus := JobStatus{
		Status: Status{
			Conditions: &[]Conditions{{
				Message:       fmt.Sprintf("Canary ID: %s\nReport URL: %s\nGate URL: %s\nScore: %s", cd.canaryId, cd.reportUrl, cd.gateUrl, cd.value),
				Type:          "OpsmxAnalysis",
				LastProbeTime: metav1.NewTime(time.Now()),
				Status:        "True",
			},
			},
		},
	}
	jsonData, err := json.Marshal(jobStatus)
	if err != nil {
		log.Errorf("could not marshal json: %s\n", err)
	}

	jobPatch, err := p.kubeclientset.BatchV1().Jobs(defaults.Namespace()).Patch(ctx, jobName, types.StrategicMergePatchType, jsonData, metav1.PatchOptions{}, "status")
	if err != nil {
		log.Errorf("%s", err)
	}
	log.Infof("json data: %s\n", jobPatch)
	patchForcefulFail(p, ctx, jobName, reason)
	os.Exit(errCode)
}

func patchJobError(p *Clients, ctx context.Context, jobName string, errMsg string) error {
	//TODO- check the meaning of the status of the Job
	jobStatus := JobStatus{
		Status: Status{
			Conditions: &[]Conditions{{
				Message:       errMsg,
				Type:          "OpsmxAnalysis",
				LastProbeTime: metav1.NewTime(time.Now()),
				Status:        "True",
			},
			},
		},
	}
	jsonData, err := json.Marshal(jobStatus)
	if err != nil {
		log.Errorf("could not marshal json: %s\n", err)
	}

	jobPatch, err := p.kubeclientset.BatchV1().Jobs(defaults.Namespace()).Patch(ctx, jobName, types.StrategicMergePatchType, jsonData, metav1.PatchOptions{}, "status")
	if err != nil {
		log.Errorf("%s", err)
	}
	log.Infof("json data: %s\n", jobPatch)
	os.Exit(1)
	return nil
}

func patchForcefulFail(p *Clients, ctx context.Context, jobName, reason string) {

	//TODO- check the meaning of the status of the Job
	jobStatus := JobStatus{
		Status: Status{
			Conditions: &[]Conditions{{
				Message:       fmt.Sprintf("The analysis was %s", reason),
				Type:          "Failed",
				LastProbeTime: metav1.NewTime(time.Now()),
				Status:        "True",
			},
			},
		},
	}
	jsonData, err := json.Marshal(jobStatus)
	if err != nil {
		log.Errorf("could not marshal json: %s\n", err)
	}

	jobPatch, err := p.kubeclientset.BatchV1().Jobs(defaults.Namespace()).Patch(ctx, jobName, types.StrategicMergePatchType, jsonData, metav1.PatchOptions{}, "status")
	if err != nil {
		log.Errorf("%s", err)
	}
	log.Infof("json data: %s\n", jobPatch)
}

func getPrevStateOfResource() {
	//TODO -Implement
}
